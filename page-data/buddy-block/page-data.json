{"componentChunkName":"component---src-containers-post-layout-tsx","path":"/buddy-block","result":{"data":{"markdownRemark":{"html":"<h3>메모리 외부 단편화</h3>\n<p>메모리는 운영체제가 관리하는 컴퓨터의 중요한 자원입니다. 프로세스는 운영체제로부터 필요한 만큼의 메모리를 할당받고 실행이 끝나면 운영체제에게 반납합니다. 컴퓨터에서 오직 하나의 프로세스만 실행할 수 있다면 메모리의 할당과 해제에 전혀 문제가 없습니다. 하지만 대다수의 운영체제는 여러 프로세스를 동시에 실행하는 멀티태스킹을 지원합니다. 프로세스들은 각자에게 필요한 메모리를 운영체제로부터 할당받고 해제하기를 반복합니다. 만약 여러 프로세스가 메모리를 차례대로 할당하게 되면 메모리의 상태는 아래와 같을 것입니다.</p>\n<p>&#x3C;여러 프로세스가 메모리를 점유한></p>\n<p>메모리는 여러 프로세스들을 위해 분리되어 있지도 않고 프로세스를 위해 아메바처럼 복제를 만들지도 않습니다. 메모리 주소는 연속적이고 프로세스는 각자의 메모리 시작주소로부터 원하는 크기만큼의 메모리를 할당받습니다. 위 그림의 A, B, C, D 프로세스 중 B, D 프로세스가 메모리를 해제한 상황을 가정해 보겠습니다.</p>\n<p>&#x3C;A, C 프로세스만 메모리를 할당받은 그림></p>\n<p>이제 새로운 프로세스 E 가 64 바이트의 메모리를 요구한다고 할 때 실제 사용 가능한 메모리는 64바이트 이상이지만 메모리가 연속적으로 존재하지 않아 프로세스 E 는 메모리를 할당 받을 수 없습니다. 이와 같은 현상을 메모리 외부 단편화라고 합니다.</p>\n<blockquote>\n<p>💡 참고로 메모리 내부 단편화는 프로세스가 사용 중인 메모리 중 사용하지 않는 메모리 공간을 갖는 경우입니다. 예를 들어 128바이트의 메모리를 할당받은 프로세스가 실제 사용하는 메모리는 100바이트라면 28바이트의 메모리가 낭비됩니다. 이 경우 메모리 내부 단편화에 해당합니다.</p>\n</blockquote>\n<p>메모리 외부 단편화는 메모리 여유가 있음에도 다른 프로세스를 실행시키지 못하니 이를 해결할 방법이 필요합니다.</p>\n<p><br/><br/><br/><br/></p>\n<h3>버디 블록 알고리즘</h3>\n<p>외부 단편화를 해결할 하나의 방법은 <strong>버디 블록</strong> 또는 <strong>버디 메모리 할당</strong>이라 불리는 알고리즘입니다. 버디 블록 알고리즘은 전체 메모리를 여러 <strong>계층</strong>의 <strong>블록</strong>으로 쪼개는 것부터 시작합니다.</p>\n<p>&#x3C;계층화된 블록 그림, 바이트 크기도 있어야 함></p>\n<p>블록의 크기가 그 윗 계층 블록 크기의 절반인 <del>굉장히 아름다운</del> 형태를 이루고 있습니다. 이제 프로세스가 메모리 할당을 요청하면 프로세스가 요구하는 메모리 크기보다 큰 적당한 크기의 블록을 프로세스에 할당해 줍니다. 예를 들어 30바이트의 메모리를 요구하는 프로세스에게는 32바이트의 메모리 블록을, 100바이트의 메모리를 요구하는 프로세스에게는 128바이트의 블록을 할당해줍니다. 이렇게 여러 프로세스에게 블록을 할당해 주다 보면 다음과 같은 상태가 될 것입니다.</p>\n<p>&#x3C;할당된 블록은 색칠한 블록 계층 그림></p>\n<p>주의할 점은 각 레벨의 메모리는 모두 <strong>같은 메모리 공간</strong>을 지칭한다는 것입니다. 단지 레벨 0은 공간을 8개의 블록으로 나누었고 레벨 1은 4개의 블록으로 나누었을 뿐입니다. 만약 레벨 1의 두번째 블록을 할당하면 블록의 범위를 포함하는 상하위 레벨 블록들은 사용할 수 없습니다.</p>\n<p>&#x3C;할당 가능한 영역만 표시></p>\n<p>모든 프로세스가 블록 형태로 메모리를 가져다 쓰고 제자리에 갖다 놓기만 하면 외부 단편화를 해결할 수 있습니다. 물론 약간의(또는 클 수도 있지만) 내부 단편화를 감수해야 하지만 외부 단편화로 인한 문제에 비하면 감수할만한 수준입니다.</p>\n<p><br/><br/><br/><br/></p>\n<h3>메모리 할당</h3>\n<p>이제 버디 블록을 구현해볼 차례입니다. 알고리즘은 크게 메모리를 할당하는 부분과 해제하는 부분으로 나뉩니다. 프로세스는 <code class=\"language-text\">void *malloc(size_t size)</code>, <code class=\"language-text\">void free(void *ptr)</code> 함수를 이용해 메모리를 할당, 해제합니다. <code class=\"language-text\">malloc</code> 은 메모리의 크기만을 매개변수로 받고 결과값으로 메모리의 주소를 반환합니다. 굉장히 제한된 정보만으로 적당한 크기의 블록과 그 주소를 알아내려 하니 조금 막막합니다. 어떻게 하면 구현할 수 있을지 다음 물음들을 살펴보겠습니다.</p>\n<ol>\n<li>요구한 메모리 크기에 적당한 크기의 블록은 무엇일까</li>\n<li>그 블록은 버디 블록 계층에서 어느 레벨에 있는 블록일까</li>\n<li>그 블록은 속해 있는 레벨에서 몇 번째 블록일까</li>\n<li>만약 해당 레벨에 할당 가능한 블록이 없다면 어떻게 해야 할까</li>\n</ol>\n<p>첫번째 물음 <em>\"요구한 메모리 크기에 적당한 크기의 블록은 무엇일까\"</em> 의 적당한 크기란 요구한 메모리 크기보다는 크지만 내부 단편화는 최소화하는 크기를 의미합니다. 버디 블록 계층에서 가장 작은 크기 블록의 사이즈를 알고 있다고 할 때 그 크기는 다음과 같이 구할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">smallestBlockSize <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">getBlockSize</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  blockSize <span class=\"token operator\">=</span> smallestBlockSize\n\n  <span class=\"token keyword\">while</span> size <span class=\"token operator\">></span> blockSize<span class=\"token punctuation\">:</span>\n    blockSize <span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n  <span class=\"token keyword\">return</span> blockSize</code></pre></div>\n<p>두번째 물음 <em>\"그 블록은 버디 블록 계층에서 어느 레벨에 있는 블록일까\"</em> 는 위 코드를 조금만 변형하면 구할 수 있습니다. 최소 크기 블록의 레벨이 0임을 이용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">smallestBlockSize <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">getBlockLevel</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  level <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  blockSize <span class=\"token operator\">=</span> smallestBlockSize\n\n  <span class=\"token keyword\">while</span> size <span class=\"token operator\">></span> blockSize<span class=\"token punctuation\">:</span>\n    blockSize <span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    level <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n  <span class=\"token keyword\">return</span> level</code></pre></div>\n<p>첫번째와 두번째 물음을 해결하면서 요구한 <code class=\"language-text\">size</code> 에 맞는 블록의 레벨을 구했습니다. 세번째 물음 <em>\"그 블록은 속해 있는 레벨에서 몇 번째 블록일까\"</em> 을 해결하기 위해 버디 블록 알고리즘은 각 블록의 상태를 관리할 메타 데이터를 이용합니다. 사실 여기서 관리할 상태란 블록을 사용할 수 있는지 없는지 여부만을 저장할 플래그 하나입니다. 아래 그림을 살펴보겠습니다.</p>\n<p>&#x3C;버디 블록 가장 기본적인 계층 그림></p>\n<p>각 블록마다 사용 가능 여부 true 또는 false 을 저장할 1바이트의 데이터를 할당해도 무리는 없지만 메모리를 더 아껴 쓰기 위해 각 블록의 상태를 1비트로 저장하겠습니다. 예를 들어 레벨 0 블록들의 개수는 8이므로 1바이트의 상태 관리용 비트맵을 아래와 같이 사용합니다.</p>\n<p>&#x3C; 10110011 비트맵></p>\n<p>만약 16개의 블록이 있다면 2바이트의 비트맵을, 100개의 블록이 있다면 100 / 8 = 12.5 를 올림한 13바이트의 비트맵을 사용합니다. 일반화하면 어떤 레벨의 블록의 개수가 n 일 때 <code class=\"language-text\">ceil(n / 8)</code>(소수점 첫번째 자리에서 올림) 크기의 비트맵이 상태 관리용으로 쓰이게 됩니다. 식에 의하면 블록 개수가 8 미만인 레벨에 대해서도 1바이트의 비트맵을 할당하므로 어떤 개수던지 <code class=\"language-text\">ceil(n / 8)</code> 을 이용해 충분한 비트맵을 할당할 수 있습니다. 아래는 <code class=\"language-text\">blockCount</code> 개의 블록을 가진 한 레벨의 비트맵을 할당하는 코드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token builtin\">bytes</span> <span class=\"token operator\">=</span> blockCount <span class=\"token operator\">//</span> <span class=\"token number\">8</span>\n\n<span class=\"token keyword\">if</span> blockCount <span class=\"token operator\">%</span> <span class=\"token number\">8</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n  <span class=\"token builtin\">bytes</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\nbitmap <span class=\"token operator\">=</span> <span class=\"token builtin\">bytearray</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>상위 레벨의 블록 개수는 바로 아래 레벨 블록 개수의 절반이므로 최하위 레벨의 블록개수를 초기값으로 아래 코드와 같이 전체 레벨에 대해 비트맵을 할당할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">smallestBlockCount <span class=\"token operator\">=</span> <span class=\"token comment\"># whatever</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">createBitmaps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  bitmaps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  blockCount <span class=\"token operator\">=</span> smallestBlockCount\n\n  <span class=\"token keyword\">while</span> blockCount <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n    <span class=\"token builtin\">bytes</span> <span class=\"token operator\">=</span> blockCount <span class=\"token operator\">//</span> <span class=\"token number\">8</span>\n    <span class=\"token keyword\">if</span> blockCount <span class=\"token operator\">%</span> <span class=\"token number\">8</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n      <span class=\"token builtin\">bytes</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    bitmap <span class=\"token operator\">=</span> <span class=\"token builtin\">bytearray</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">bytes</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># e.g. bytearray[3] = [0, 0, 0]</span>\n\n    bitmaps<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>bitmap<span class=\"token punctuation\">)</span>\n    blockCount <span class=\"token operator\">//=</span> <span class=\"token number\">2</span>\n\n  <span class=\"token keyword\">return</span> bitmaps</code></pre></div>\n<p><code class=\"language-text\">createBitmaps</code> 함수로 만들어진 비트맵 배열은 각 레벨을 인덱스로 해당 레벨의 비트맵을 읽을 수 있습니다. 예를 들어 <code class=\"language-text\">bitmaps[0]</code> 는 레벨 0의 비트맵이고 레벨 0의 0번째 블록의 상태는 <code class=\"language-text\">bitmaps[0][0] &amp; (1 &lt;&lt; 0)</code> 와 같이, 19번째 블록의 상태는 <code class=\"language-text\">bitmaps[0][2] &amp; (1 &lt;&lt; 3)</code> 와 같이 읽을 수 있습니다. 이제 비트맵을 이용해 세번째 물음 \"<em>그 블록은 속해 있는 레벨에서 몇 번째 블록일까</em>\" 를 해결했습니다.</p>\n<p>블록의 상태는 1일 때 사용 가능, 0일 때 사용 불가능하다고 하면 위에서 작성한 함수 <code class=\"language-text\">createBitmaps</code> 는 모든 비트를 0으로 초기화하므로 비트맵은 만들었지만 사용할 수 있는 블록이 한 개도 없는 상태입니다. 네번째 물음 \"<em>만약 해당 레벨에 할당 가능한 블록이 없다면 어떻게 해야 할까</em>\" 역시 이 물음의 답을 요구하고 있습니다.</p>\n<p>모든 블록을 사용 가능으로 표시하기 위해 비트맵의 값을 0xFF 로 초기화해야 할까요? 0xFF 로 초기화한다면 비트맵 상태가 가리키는 모습은 아래와 같습니다.</p>\n<p>&#x3C;모든 비트가 1일 때 블록의 상태를 표현, 전부 초록색으로></p>\n<p>레벨 1의 1번째 블록을 사용한다고 하면 <code class=\"language-text\">bitmaps[1][0] &amp;= ~(1 &lt;&lt; 1)</code> 과 같이 비트를 0으로 만들어주고 적절한 비트 연산과 나눗셈, 모듈로 연산을 이용해 해당 블록의 주소를 반환해 주면 됩니다. 그리고 각 레벨은 사실 같은 메모리 공간을 가리키고 있으므로 레벨 1의 1번째 블록을 범위로 포함하는 상하위 레벨의 블록들 역시 대응하는 비트맵의 상태를 0으로 바꿔 주어야 합니다.</p>\n<p>&#x3C;상하위로 비트 0이된 모습></p>\n<p>매번 할당할 때마다 상하위 레벨 블록들의 상태까지 신경 써 줘야 하는게 복잡하게 보입니다. 버디 블록은 이같이 복잡하고 비효율적인 방법 대신 짝이 없는 잉여 블록을 사용 가능한 상태로 초기화합니다. 그리고 원하는 레벨의 블록을 찾기 위해 상위 레벨의 블록을 쪼개는 방법을 이용합니다. 예를 들어 아래와 같이 초기화된 블록 계층이 있을 때 가장 상위 레벨의 블록은 한 개 뿐이므로 짝이 없는 <strong>잉여 블록</strong>입니다.</p>\n<p>&#x3C;최상위 블록만 1인 상태와 비트맵></p>\n<p>위 상태에서 100바이트의 메모리를 요구하는 프로세스가 있다고 하겠습니다. 100바이트의 메모리는 <code class=\"language-text\">getBlockLevel(100)</code> 을 통해 레벨 2임을 알 수 있습니다. 하지만 보시다시피 레벨 2의 비트맵은 전부 0인 상태입니다. 버디 블록 알고리즘은 상위 레벨에 사용 가능한 블록이 있는지 탐색합니다. 레벨 2의 상위 레벨인 레벨 3에는 사용 가능한 블록이 있습니다. 레벨 3의 블록의 크기는 레벨 2블록 크기의 두 배이므로 레벨 3블록을 반으로 쪼개 그 중 하나를 사용하면 됩니다. 레벨 3의 블록을 반으로 쪼개면 아래와 같습니다.</p>\n<p>&#x3C;레벨 3쪼갠 그림></p>\n<p>레벨 2에 사용 가능한 블록이 존재하므로 이 중 하나를 사용하고 다른 하나는 사용 가능 블록으로 남겨 둡니다.</p>\n<p>100바이트의 메모리가 할당 된 후 이번엔 20바이트의 메모리를 요구하는 프로세스가 있다고 하겠습니다. 20바이트의 메모리는 <code class=\"language-text\">getBlockLevel(20)</code> 을 통해 레벨 0임을 알 수 있습니다. 현재 레벨 0에는 사용 가능한 블록이 없으니 레벨 1을 탐색해 보지만 레벨 1 역시 사용 가능한 블록이 없습니다. 따라서 레벨 2의 사용 가능한 블록을 쪼개 두 개의 레벨 1 블록을 사용 가능한 상태로 만들고, 다시 레벨 1 블록 중 하나를 쪼개 두 개의 레벨 0의 블록을 사용 가능한 상태로 만듭니다.</p>\n<p>&#x3C;레벨 2 -> 레벨 0까지 쪼개는 모습 과정></p>\n<p>이 과정을 코드로 작성해 보겠습니다.</p>\n<ul>\n<li>이 때 계층간의 관계는 idx, idx * 2, idx * 2 + 1 로 부모 자식, buddy 관계</li>\n<li>프로세스가 요구하는 메모리 크기를 커버할 수 있는 블록을 할당 이 때 해당 레벨에 남는 블록이 없다면 부모로부터 split</li>\n<li>버디 블록 알고리즘을 보조하는 자료 구조 등장</li>\n<li>메모리가 사용 가능한지 어떻게 판단? bitmaps</li>\n<li>free 시 ptr 에 얼마만큼의 메모리가 할당되었는지? levelOfBlock 이용</li>\n</ul>\n<h3>코드</h3>\n<ul>\n<li>홀수로 남는 경우 잉여 블록! avail 한 상태로 남겨둠</li>\n</ul>","frontmatter":{"date":null,"slug":"/buddy-block","title":"버디 블록 알고리즘","tags":["메모리 단편화","동적 메모리"],"category":["운영체제"],"description":"메모리의 외부 단편화를 해결하는 방법"}}},"pageContext":{"slug":"/buddy-block","categories":[{"category":"선형대수학","count":26,"href":"/category/선형대수학"},{"category":"그래픽스","count":14,"href":"/category/그래픽스"},{"category":"병렬 프로그래밍","count":3,"href":"/category/병렬 프로그래밍"},{"category":"최적화 문제","count":3,"href":"/category/최적화 문제"},{"category":"알고리즘","count":2,"href":"/category/알고리즘"},{"category":"미적분","count":2,"href":"/category/미적분"},{"category":"운영체제","count":1,"href":"/category/운영체제"}],"tags":[{"tag":"코딩 더 매트릭스","count":24,"href":"/tag/코딩 더 매트릭스"},{"tag":"python","count":24,"href":"/tag/python"},{"tag":"레이 트레이싱","count":7,"href":"/tag/레이 트레이싱"},{"tag":"알고리즘","count":4,"href":"/tag/알고리즘"},{"tag":"OpenCL","count":3,"href":"/tag/OpenCL"},{"tag":"C","count":3,"href":"/tag/C"},{"tag":"회전","count":3,"href":"/tag/회전"},{"tag":"행렬","count":2,"href":"/tag/행렬"},{"tag":"그래픽스","count":2,"href":"/tag/그래픽스"},{"tag":"벡터","count":2,"href":"/tag/벡터"},{"tag":"라그랑주 승수법","count":2,"href":"/tag/라그랑주 승수법"},{"tag":"메모리 단편화","count":1,"href":"/tag/메모리 단편화"},{"tag":"동적 메모리","count":1,"href":"/tag/동적 메모리"},{"tag":"기저","count":1,"href":"/tag/기저"},{"tag":"정렬","count":1,"href":"/tag/정렬"},{"tag":"연결 리스트","count":1,"href":"/tag/연결 리스트"},{"tag":"문자열 탐색","count":1,"href":"/tag/문자열 탐색"},{"tag":"복소수","count":1,"href":"/tag/복소수"},{"tag":"사원수","count":1,"href":"/tag/사원수"},{"tag":"쿼터니언","count":1,"href":"/tag/쿼터니언"},{"tag":"선형대수학","count":1,"href":"/tag/선형대수학"},{"tag":"Gradient 벡터","count":1,"href":"/tag/Gradient 벡터"},{"tag":"편미분","count":1,"href":"/tag/편미분"},{"tag":"전미분","count":1,"href":"/tag/전미분"},{"tag":"확률분포","count":1,"href":"/tag/확률분포"}]}}}